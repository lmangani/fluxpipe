const fs = require('fs');
const path = require('path');


 // Import file generated by flux builds
const jsonInput = require("./flux-docs-short.json")

// Create directories recursively
function createDirectoriesRecursive(filePath) {
  const directory = path.dirname(filePath);
  if (!fs.existsSync(directory)) {
    fs.mkdirSync(directory, { recursive: true });
  }
}

// Create Markdown documentation for a function
function createFunctionMarkdown(func) {
  const { name, headline, description, parameters, flux_type } = func;
  let markdown = `### \`${name}()\`\n\n`;
  markdown += `${headline}\n\n`;
  markdown += '#### Function type signature\n\n';
  markdown += '```flux\n';
  markdown += `${flux_type || "No type signature provided"}\n`;
  markdown += '```\n\n';
  markdown += '#### Parameters\n\n';

  if (parameters && parameters.length > 0) {
    markdown += '| Parameter | Description | Required |\n';
    markdown += '| --- | --- | --- |\n';
    parameters.forEach(param => {
      markdown += `| ${param.name || ""} | ${param.headline || ""} | ${param.required ? 'Yes' : 'No'} |\n`;
      if (param.description) {
        markdown += `| | ${param.description} | |\n`;
      }
    });
  } else {
    markdown += 'No parameters provided.\n\n';
  }

  return markdown;
}

// Create Markdown documentation for the entire package
function createPackageMarkdown(packageInfo) {
  const { name, headline, members } = packageInfo;
  let markdown = `## \`${name}\` package\n\n`;
  markdown += `${headline || "No package description provided"}\n\n`;
  markdown += 'Import the `' + name + '` package:\n\n';
  markdown += '```flux\n';
  markdown += `import "${name}"\n`;
  markdown += '```\n\n';
  markdown += '### Functions\n\n';

  if (members) {
    Object.keys(members).forEach(memberName => {
      const member = members[memberName];
      markdown += createFunctionMarkdown(member);
    });
  } else {
    markdown += 'No functions provided.\n\n';
  }

  return markdown;
}

// Generate documentation for all packages
function generateDocumentation(jsonInput) {
  jsonInput.forEach(packageInfo => {
    const { path } = packageInfo;
    const markdown = createPackageMarkdown(packageInfo);
    const filename = `${path}.md`;

    // Ensure directories exist before writing the file
    createDirectoriesRecursive(filename);

    fs.writeFileSync(filename, markdown);
    console.log(`Generated documentation for ${path}`);
  });
}

// Generate sidebar index with light nesting
function generateSidebarIndex(jsonInput) {
  let sidebarIndex = '## \n\n';

  // Create a map to organize packages and functions by the first section of $path
  const sidebarMap = {};

  jsonInput.forEach(packageInfo => {
    const { path, name } = packageInfo;
    const pathSections = path.split('/');
    const firstSection = pathSections[0];

    sidebarMap[firstSection] = sidebarMap[firstSection] || [];
    sidebarMap[firstSection].push({ name, path });
  });

  // Generate sidebar entries with light nesting
  for (const section in sidebarMap) {
    sidebarIndex += `- [${section}](/${section}.md)\n`;
    sidebarMap[section].forEach(functionInfo => {
      const { name, path } = functionInfo;
      sidebarIndex += `  - [${name}](${path}.md)\n`;
    });
  }

  fs.writeFileSync('_sidebar.md', sidebarIndex);
  console.log('Generated sidebar index with light nesting');
}

// Generate documentation and sidebar index
generateDocumentation(jsonInput);
generateSidebarIndex(jsonInput);
